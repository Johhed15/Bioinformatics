---
title: "Lab 2"
date: "`r Sys.Date()`"
author: "Johannes Hedström, Mikael Montén"
output:
  pdf_document:
    latex_engine: xelatex
    fig_caption: yes
    number_sections: yes
  html_document:
    df_print: paged
geometry: top=100pt,bottom=100pt,left=68pt,right=66pt
header-includes:
- \usepackage{float}
- \usepackage{longtable}
- \usepackage{caption}
- \usepackage{fancyhdr}
- \usepackage{titling}
- \renewcommand{\headrulewidth}{0pt}
- \renewcommand{\and}{\\}
- \pretitle{\centering\vspace{0cm}{732A51 Bioinformatics \par}\vspace{5cm}\Huge\textbf}
- \posttitle{\vspace{1cm}\large\textbf{}\par}
- \preauthor{\centering\vspace{4cm}\normalsize}
- \postauthor{\par\vspace{2cm}}
- \predate{\centering{\normalsize STIMA \\
  Institutionen för datavetenskap \\ Linköpings universitet \par}}
- \postdate{\par\vspace{0cm}}
- \raggedbottom
---

<!-- page number pos -->
\fancyhf{}
\fancyfoot[C]{\thepage}
\pagestyle{fancy}

<!-- no page nr on first page  -->
\pagenumbering{gobble}

<!-- Anger sidbrytning -->
\clearpage

<!-- creating the table of contents -->
\setcounter{tocdepth}{3}
\tableofcontents

<!-- new page -->
\clearpage

<!-- starting the count on 1 after the contents -->
\pagenumbering{arabic}
\setcounter{page}{1}

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning=FALSE, fig.width = 6, fig.height = 4)
```

# Question 1: DNA sequence acquisition and simulation

*In this exercise you will perform statistical analysis of three nucleotide data sets. First download the sequences from GenBank and save them in a fasta file. For this use the provided R script, 732A51 BioinformaticsHT2023 Lab02 GenBankGetCode.R. This is a dataset of the RAG1 gene sequences from 33 lizard species. You are encouraged to read in detail the references in the script as they indicate many useful tools. Explore the dataset using the tools provided by the ape and seqinr packages. Take note of the lengths of all the sequences and the base composition.*

```{r}
library(ape)
library(seqinr)
library(phangorn)

## Gene bank accession numbers taken from http://www.jcsantosresearch.org/Class_2014_Spring_Comparative/pdf/week_2/Jan_13_15_2015_GenBank_part_2.pdf
lizards_accession_numbers <- c("JF806202", "HM161150", "FJ356743", "JF806205", 
                               "JQ073190", "GU457971", "FJ356741", "JF806207",
                               "JF806210", "AY662592", "AY662591", "FJ356748",       
                               "JN112660", "AY662594", "JN112661", "HQ876437", 
                               "HQ876434", "AY662590", "FJ356740", "JF806214", 
                               "JQ073188", "FJ356749", "JQ073189", "JF806216", 
                               "AY662598", "JN112653", "JF806204", "FJ356747", 
                               "FJ356744", "HQ876440", "JN112651", "JF806215",
                               "JF806209") 
lizards_sequences<-ape::read.GenBank(lizards_accession_numbers)
print(lizards_sequences)

```

\pagebreak

## Question 1.1

*Simulate an artificial DNA sequence dataset. It should contain 33 sequence. The lengths of the sequences should be the same as in the lizard dataset, i.e. for each real sequence simulate an artificial one. The simulation rule is as follows, each nucleotide is to be independently and randomly drawn from the distribution given by the base composition (frequencies) in the true lizard sequences. Save your dataset in a fasta format file. Remember to give unique names to your sequences. Report on the base composition in your simulated data.*

```{r}
#library(help = ape)
#library(help = seqinr)
set.seed(123456790)
#ape::as.character.DNAbin(lizards_sequences[[1]])


artif_dna_seq <- function(org_seq){
  new_seq <- list()
  
  for(i in 1:length(org_seq)){
    comp_dist <- base.freq(org_seq[i][1]) # extract base compositions 
    seq_len <- length(org_seq[[i]]) # extract length of sequence
    # sample according to individual base comp distribution and length
    new_seq[[i]] <- sample(c("a", "c", "g", "t"), size = seq_len, replace = TRUE, prob = comp_dist)
  }
  # set unique names according to original sequence
  names(new_seq) <- paste0("ARTIFICAL_",names(org_seq)) 
  return(new_seq)
}

artif_liz_seq <- artif_dna_seq(lizards_sequences)
# save dataset as fasta
#seqinr::write.fasta(sequences =artif_liz_seq, 
#                    names = names(artif_liz_seq), 
#                    file.out = "artifical_lizard_seqs.fasta")

# report on base composition
artif_liz_seq_DNAbin <- as.DNAbin(artif_liz_seq)

seq_compare <- rbind(base.freq(lizards_sequences),base.freq(artif_liz_seq_DNAbin))
rownames(seq_compare) <- c("Lizards sequences", "Artif. lizards sequences")
knitr::kable(seq_compare, caption="Base compositions")

```

Comparing the base compositions for the original lizards_sequences FASTA file and the artificially created lizards_sequences, we can see that the base compositions are nearly identical eachother with minimal differences between the sequences.


## Question 1.2 
*Simulate a second artificial DNA sequence dataset. It should contain 33 sequence. The lengthsof the sequences should be the same as in the lizard dataset, i.e. for each real sequence simulatean artificial one. First simulate a phylogenetic tree with 33 tips in phylo format (i.e. ape). Plotyour resulting tree. For simulating the tree explore the functions of the ape, TreeSim or other Rpackages. Choose a simulation function and model yourself.Now simulate sequences on this using e.g. phangorn::simSeq(). Choose the sequence lengthyourself, but try to make it so that it will be comparable with the original lizards dataset. Youneed to also specify the Q matrix|the transition rate matrix. Choose one yourself, howevertry to make the stationary distribution equal to the base composition (frequencies) of the lizardsequences (look at EG Ch. 14:3:3). If you cannot obtain such a transition matrix, choose someanother one. Save your dataset in a fasta format file. Remember to give unique names to yoursequences. Report on the base composition in your simulated data. Comment on if it is whatyou expect.*

```{r}
# simulate second artifical DNA seq with 33 sequences and same lengths
a_seq2 <- artif_dna_seq(lizards_sequences)

# simulate a phylogenetic tree with 33 tips in phylo format
a_seq_tree <- rtree(n = length(a_seq2))
# set node names to match sequences
a_seq_tree$tip.label <- names(a_seq2)
```

\pagebreak
```{r, fig.height = 7, fig.cap = "Phylogenetic tree of artifical DNA sequences", echo = FALSE}
# plot phylogenetic tree with scale bar for branch length
plot(a_seq_tree, main = "Simulated phylogenetic tree")
```


```{r}
as.DNAbin(a_seq2)
```

\pagebreak

As the mean DNA sequence length is 1982.879, this will be used to simulate sequences of length 1983. The base compositions shown above is what will be used as stationary distribution for the Q-matrix as well.

$$\vec{\phi_0} = (0.310, 0.203, 0.234, 0.254)^T$$

$$\mathbf{Q}=\left[\begin{array}{llll}
q_{A A} & q_{A C} & q_{A G} & q_{A T} \\
q_{C A} & q_{C C} & q_{C G} & q_{C T} \\
q_{G A} & q_{G C} & q_{G G} & q_{G T} \\
q_{T A} & q_{T C} & q_{T G} & q_{T T}
\end{array}\right]$$


So that diagonal elements satisfy $q_{ii} = - \sum_{i \neq j} q_{ij}$, which means row sums = 0. According to https://en.wikipedia.org/wiki/Models_of_DNA_evolution#Ergodicity, a stationary distribution $\pi$ satisfies $\pi Q = 0 \implies \vec{\phi_0} Q = 0$ which is the result to look for when constructing the Q-matrix.

Creating a symmetric Felsenstein model according to https://en.wikipedia.org/wiki/Models_of_DNA_evolution#F81_model_(Felsenstein_1981).

$$\mathbf{Q}=\left[\begin{array}{llll}
* & \phi_0^C & \phi_0^G & \phi_0^T \\
\phi_0^A & * & \phi_0^G & \phi_0^T \\
\phi_0^A & \phi_0^C & * & \phi_0^T \\
\phi_0^A & \phi_0^C & \phi_0^G & *
\end{array}\right]$$

```{r}
# sequence length
n <- 1983

# base composition
phi <- base.freq(as.DNAbin(a_seq2))

# initialize Q
Q <- matrix(0, nrow = 4, ncol = 4)
colnames(Q) <- c("a","c","g","t")
rownames(Q) <- c("a","c","g","t")

# fill each non-diagonal with the base comp
for (i in 1:4) {
  for (j in 1:4) {
    if (i != j) {
      Q[i,j] <- phi[j]
    }
  }
}

# fill diagonal to ensure row sums to 0
diag(Q) <- -rowSums(Q)

print(Q)

# confirm the assumption holds
phi %*% Q
```
The Q-matrix constructed according to the Felsenstein model works good as a transition matrix, which is evident that the result is 0 or nearly 0 for all bases when computing $\vec{\phi_0} Q$.


```{r}
# simulate sequences
phyl_seq <- simSeq(a_seq_tree, l = n, Q = Q, bf = phi, type = "DNA")
# save as FASTA
#write.phyDat(phyl_seq, file = "simulated_phylogeny_sequences.fasta", format = "fasta")

as.DNAbin(phyl_seq)

seq_compare <- rbind(base.freq(as.DNAbin(phyl_seq)),base.freq(as.DNAbin(a_seq2)))
rownames(seq_compare) <- c("Phylogeny simulated sequence", "Second simulated sequence")
knitr::kable(seq_compare, caption="Base compositions")
```

Comparing the base compositions of these simulated data, they are closely aligned each other. This is the result that we expected so the phylogeny simulations seem to be working well.




# Sequence analysis

```{r}
# file from Ying
codon_ORF <- read.csv('codon_and_ORF.csv')
```

## Question 2.1

*Report some basic statistics on each sequence dataset: individual base composition, GC content,CG, AT content. Also translate your sequences into protein sequences (see Lab 1) and report on the amino acid composition. In your simulated sequences, how many times did you observe a stop codon inside your sequence? Does this occur in your true sequences? Comment.*

```{r}
library(stringr)

# function to calculate basic stats from a DNA sequence
dna_stats <- function(seq){
  
  alf_seq <- as.character(seq) # from binary to letters
  sequence_str <- paste(unlist(alf_seq), collapse = "")# 1 long sequence 
  
  # Create the dinucleotides for the CpG calculations
  dinucleotides <- substring(sequence_str, 1:(nchar(sequence_str) - 1), 2:nchar(sequence_str))
  # Counting the dinucleotide
  counts <- table(dinucleotides)
  # Calculate CpG content 
  CpG <- counts['cg'] / sum(counts) 

  base_comp <- base.freq(seq[1]) # base comp 
  GC <- GC.content(seq[1]) # GC and AT content
  AT <- 1 - GC

  return(t(c('Species'=names(seq),base_comp[1],base_comp[2],base_comp[3],base_comp[4],GC,AT, CpG)))
}

df <- as.data.frame(dna_stats(lizards_sequences[1]))

df <- rbind(df,dna_stats(artif_liz_seq_DNAbin[1]))
colnames(df)[6:8] <-c('GC','AT', 'CpG') 
df[ , 2:8] <- sapply(df[ , 2:8], as.numeric)
df[ , 2:8] <- round(df[ , 2:8], digits = 5)
knitr::kable(df)

```

The proportions for the different stats looks to be close to the same for the specie JF806202 except for the CpG which is much higher for the artificial.



```{r}
# Translate DNA sequences to protein sequences

translate_sequences <- function(seq) {
  alf_seq <- as.character(seq) # from binary to letters
  sequence_str <- paste(unlist(alf_seq), collapse = "") # 1 long sequence 
  
  name <- names(seq) # picking out the name to get correct start pos
  start <- codon_ORF[codon_ORF$accession==name,2] -1 # 0-2 in the function
  protein <- translate(s2c(sequence_str), frame=start) # Translation table 1 (Standard Code)
  
  return(list(name=name,protein=protein))
}


# Translate all true sequences
protein_sequences <- lapply(1:33, function(i) translate_sequences(lizards_sequences[i]))
print(protein_sequences[1])


```


```{r}

sim <- read.fasta('sim.fasta') # simulated proteins sequances

table(sim$ARTIFICAL_JF806202_1) 

```

The number of stop codons in the simulated sequence for JF806202 after translations to proteins are 20, which can be seen as the number below the star(*) in the table above. The true sequence have 0 stop codons, the difference here is that in the simulated sequence there is a possibility to sample nucleotides that create stop codons( TAA, TAG, and TGA) without any constraints which there is likely to be for the true sequence where the coding regions are complete and translated into functional proteins. 







## Question 2.3

*Align your sequences using software of your choice (a starter for R: https://stackoverflow.com/questions/4497747/how-to-perform-basic-multiple-sequence-alignments-in-r, you can also look what Biopython, BioPerl offer, use the Clustal family of programs or something else of your choice). Choose a distance measure between sequences, calculate for each alignment the distances between all pairs of sequences. Then, plot heatmaps visualizing the distances. Comment on what you can observe.*



\newpage

# Phylogeny reconstruction

## Question 3.1

*Construct (using algorithm and software of your choice) phylogenetic trees from the three multiple alignments (or distance matrices) done in Question 2.3. You might want to look at the functions offered by ape, phangorn (https://cran.r-project.org/web/packages/phangorn/vignettes/Trees.pdf) or go for some completely different software. Plot the inferred trees. Are the two based on the simulated data similar to expected? Perform a phylogenetic bootstrap analysis and report the bootstrap support for the individual clades, you can look at ape::boot.phylo().*

